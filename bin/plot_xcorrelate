#!/usr/bin/python

"""
Cross-correlate sky location probability maps for an external GRB trigger
and a gravitational-wave candidate event
"""
__author__ = "Alex Urban <alexander.urban@ligo.org>"

import numpy as np
import healpy as hp
from optparse import Option, OptionParser

# read in options from command line
opts, args = OptionParser(
    description = __doc__,
    usage = "%prog [options]",
    option_list = [
        Option("-o", "--output", metavar="FILE.{pdf,png}",
            help="name of output file"),
        Option("--colormap", default="jet",
            help="name of matplotlib colormap [default: %default]"),
        Option("-s", "--skymap", metavar="FILE.fits", default="skymap.fits.gz",
            help="name of HEALPix .fits file containing skymap of GW candidate "
                + "(default: 'skymap.fits.gz')"),
        Option("--contour", metavar="PERCENT", type=float, action="append",
            default=[], help="plot contour enclosing this percentage of"
            + " probability mass [may be specified multiple times [default: none]"),
        Option("--figure-width", type=float, default=8.,
            help="width of figure in inches (default = 8 in.)"),
        Option("--figure-height", type=float, default=8.,
            help="height of figure in inches (default = 8 in.)"),
        Option("-t","--trigger",metavar="FILE.fits",
            help="name of HEALPix .fits file containing skymap of external trigger")
    ]
).parse_args()

if opts.trigger is None:
    import sys
    print 'ERROR: Valid GRB .fits file not specified'
    sys.exit(1)


# Late imports

# Choose a matplotlib backend that is suitable for headless
# rendering if output to file is requested
import matplotlib as mpl
if opts.output is not None:
    mpl.use('agg')

import matplotlib.pyplot as plt
import matplotlib.cm as cm
from lalinference.bayestar import fits
from lalinference.bayestar import plot


# Read in GRB and GW skymaps
grb_skymap, grb_metadata = fits.read_sky_map(opts.trigger)
gw_skymap, gw_metadata = fits.read_sky_map(opts.skymap)

# Calculate number of pixels per side for each map
nside1 = hp.npix2nside(len(gw_skymap))
nside2 = hp.npix2nside(len(grb_skymap))

# If skymaps are of different length, up- or downgrade 
# the size of the GRB skymap
if nside1 != nside2: grb_skymap = hp.ud_grade(grb_skymap, nside1, power=2)

# Get a list of all indices in the GRB skymap that 
# correspond to nonzero probability mass
ind = [i for i, p in enumerate(grb_skymap) if p != 0.]
th, ph = hp.pix2ang(nside1, ind)

# Now define the sliding dot product, knowing only a small number
# of nonzero GRB values will contribute to the sum
def correct_ang(theta, phi):
    """ Map angles that go out of range back to where they 
        ought to be on the unit sphere """
    for i in xrange(len(theta)):
        if theta[i] < 0.:
            theta[i] = -theta[i]
            phi[i] += np.pi
        elif theta[i] > np.pi:
            theta[i] = 2*np.pi - theta[i]
            phi[i] -= np.pi

    return theta, np.mod(phi, 2*np.pi)

def pdf_xcorr(dth, dph):
    """ Probability distribution function P(th2-th1, ph2-ph1) """
    theta, phi = correct_ang([x-dth for x in th], [x-dph for x in ph])
    ind2 = hp.ang2pix(nside1, theta, phi)

    pdf = 0.
    for i in xrange(len(ind)): 
        pdf += gw_skymap[ind2[i]] * grb_skymap[ind[i]]

    return pdf

# Cross-correlation map is the distribution of the difference
# between GRB and GW sky locations
da, th0 = 0.01, th.min()
dth = np.arange(th0-np.pi, th0+da, da)
dph = np.arange(-np.pi, np.pi+da, da)
xcor = np.array([pdf_xcorr(t, p) for t in dth for p in dph])

# Shift dtheta values to lie in (-pi/2, pi/2]
for i in xrange(len(dth)): 
    if dth[i] >= np.pi/2: dth[i] -= np.pi
    if dth[i] < -np.pi/2: dth[i] += np.pi

# Normalize the cross-correlation distribution
diff = len(gw_skymap)/float(len(xcor))
xcor /= np.sum(xcor)


## Produce a rectangular heatmap of the cross-correlation
fig = plt.figure(figsize=(opts.figure_width, opts.figure_height), frameon=False)
ax = plt.subplot(111)
ax.grid()

# Convert sky map from probability to probability density
probdens = xcor / (hp.nside2pixarea(nside1) * diff)
vmax = probdens.max()

# Generate heatmap plot
X, Y = np.meshgrid(dph,dth)
x = X.ravel()
y = Y.ravel()
plt.hexbin(x, y, probdens, gridsize=(500,1000), vmax=vmax)

# Plot colorbar
cb = plot.colorbar(vmax)

# Set colorbar label
cb.set_label(r'prob. per steradian')

# Add contours
if opts.contour:
    indices = np.argsort(-xcor)
    region = np.empty(xcor.shape)
    region[indices] = 100 * np.cumsum(xcor[indices])
    cs = plt.contour(dph, dth, np.reshape(region, (len(dth), len(dph))), 
        levels=opts.contour, colors='k')
    plt.clabel(cs, fmt='%g%%', fontsize=6, inline=True)

    # Find the smallest contour with the origin in its closure under S^2
    x1, y1 = x.tolist(), y.tolist()
    k = next(z[0] for z in enumerate(x1) if abs(z[1]) < 0.01 or z[1] >= 0.)
    l = next(z[0] for z in enumerate(y1) if abs(z[1]) < 0.01 or z[1] >= 0.)
    cont = region[k + l]

plt.axis([-np.pi, np.pi, -np.pi/2, np.pi/2])
plt.xlabel(r'$\Delta\varphi$')
plt.ylabel(r'$\Delta\theta$')

# If we are using a new enough version of matplotlib, then
# add a white outline to all text to make it stand out from the background.
plot.outline_text(ax)

fig.patch.set_alpha(0.)
ax.patch.set_alpha(0.)
ax.set_alpha(0.)


if opts.output is None:
    plt.show()
else:
    plt.savefig(opts.output)

    from ligo.gracedb.rest import GraceDb
    gracedb = GraceDb()

    # Submit plot to GraCEDb
    uid = gw_metadata['objid']
    message = "Smallest probability contour containing the origin is %.3f%%, " % cont
    message += "corresponding to %.3f%% confidence" % (100 - cont)
    print message

    # Publish to both GW and external trigger profiles
    gracedb.writeLog(uid, message, filename=opts.output, tagname="sky_loc")
